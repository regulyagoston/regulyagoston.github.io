[{"name":"app.R","content":"\nlibrary(shiny)\nlibrary(shinyjs)\nlibrary(stringr)\n#path_dir <- '~/Library/CloudStorage/OneDrive-CorvinusUniversityofBudapest/Teaching/Okonometria_I/2024_25_osz/codes/autograder_shiny_bu'\nsource('./R/grade.r')\nsource('./R/uni_grader.R')\n\n# Set the MAX minutes to process\nmints = 1\nneptun_codes = c('asd123','gvk123')\n\n##\n# Slide bars\nui <- fluidPage(\n  useShinyjs(),\n  \n  tags$br(), \n  tags$br(),\n  \n  fluidPage(\n    h3(\"Upload R-script\"),\n    fileInput('inFile', 'Choose file'),\n    actionButton('reset', 'Reset'),\n    h3(\"Script status:\"),\n    verbatimTextOutput(\"summary\"),\n    verbatimTextOutput(\"chck_name\")\n  ),\n  \n  tags$br(), \n  tags$br(),\n  \n  fluidPage(\n    h3(\"Select Assignment\"),\n    selectInput(\"assign\", \"Assignment:\",\n                c(\"Assignment 1\" = \"as1\",\n                  \"Assignment 2\" = \"as2\",\n                  \"Assignment 3\" = \"as3\")),\n    tags$br(),\n    fluidRow(\n      actionButton('grade', 'Autograde', class = \"btn-primary\"),\n      #actionButton(\"stop\", \"Stop\", class = \"btn-danger\"),\n      actionButton('grade_reset', 'Reset')\n    ),\n    h6(paste('Autograding can take up to ', mints, ' minutes maximum.')),\n    h6('After that it will exit and not evaluate your code.'),\n    tags$br(),\n    h3(\"Grade status:\"),\n    tableOutput(\"grade_res\"),\n    verbatimTextOutput(\"grade_sum\")\n  )\n  \n) # close fluid page\n\n#####\n# Server\nserver <- function(input, output, session) {\n  \n  \n  ########################\n  # Handle uploaded file\n  # Reset submitted script\n  values <- reactiveValues(\n    upload_state = NULL\n  )\n  \n  # New upload\n  observeEvent(input$inFile, {\n    values$upload_state <- 'Uploaded'\n  })\n  \n  observeEvent(input$reset, {\n    shinyjs::reset()\n    values$upload_state <- NULL\n    hide(\"grade_res\")\n    hide(\"grade_sum\")\n  })\n  \n  \n  file_input <- reactive({\n    if (is.null(values$upload_state)) {\n      return(\"No file uploaded.\")\n    } else if (values$upload_state == 'Uploaded') {\n      return(input$inFile)\n    }\n  })\n  \n  ##\n  # Output for file upload\n  output$summary <- renderText({\n    txt = ifelse( values$upload_state == 'Uploaded' , \n                  paste(\"Uploaded file:\", file_input()$name ),\n                  file_input() )\n    return(txt)\n  })\n  \n  ##\n  # Check validity of uploaded name\n  output$chck_name <- renderText({\n    \n    # chck function\n    chck_name <- function( inputfile ){\n      tryCatch({\n        any( substr( file_input()$name, 0, 6 ) == neptun_codes )\n      }, \n      error = function( e )\n        NULL\n      )\n    }\n    \n    txt = ifelse( !is.null( chck_name ),\n                  ifelse( chck_name(),\n                          'Valid script name!',\n                          'Invalid script name! Use your neptun code as the first 6 character of your submission file!' ),\n                  'No file uploaded!')\n    \n    return(txt)\n    \n    #if ( values$upload_state == 'Uploaded' ){\n    #  chck = any( substr( file_input()$name, 0, 6 ) == neptun_codes )\n    #  if ( chck ){\n    #    txt = 'Valid script name!'\n    #  } else{\n    #    txt = 'Invalid script name! Use your neptun code as the first 6 character of your submission file!'\n    #  }\n    #} else{\n    #  txt = ''\n    #}\n    \n  })\n  \n  ########################\n  # Process uploaded file\n  \n  grading <- eventReactive( input$grade, {\n    if ( is.character( file_input ) ){\n      \n      showNotification(\"No script file uploaded!\")\n      overflow = F\n      grade_res = NULL\n      \n    } else{\n      \n      showNotification(\"Grading in progress!\")\n      \n      # Process input\n      #script = readLines( input$inFile$datapath )\n      path_file = file_input()$datapath\n      \n      # Start grading\n      if ( input$assign == 'as1' ){\n        Mytestfile <- './solutions/solution_week01.R'\n      } else if ( input$assign == 'as2' ){\n        Mytestfile <- './solutions/solution_week02.R'\n      }\n      \n      # Eval function\n      grade <- function( path_file, Mytestfile ){\n        tryCatch({\n          calc_one_Grade( path_file, Mytestfile,\n                          suppress_warnings = F,\n                          verbose = TRUE )\n        }, \n        error = function( e )\n          NULL\n        )\n      }\n      \n      setTimeLimit( elapsed = mints*60 ) # After x minutes it will shut downe\n      st=Sys.time()\n      grade_res <- grade( path_file, Mytestfile )\n      et = Sys.time() - st\n      setTimeLimit( elapsed = Inf )\n      \n      overflow = F\n      if ( et >= mints ){\n        grade_res = NULL\n        overflow =T \n      }\n      \n      if ( !is.null( grade_res ) ){\n        # Remove ID\n        grade_res[,1] = NULL\n        \n        # Inform\n        showNotification(\"Grading is done!\")\n      } else{\n        \n        # Inform\n        showNotification(paste(\"Grading takes more than \", mints,\n                               \" minutes! Revise your code!\") )\n      }\n    }\n    return( list( grade_res = grade_res, overflow = overflow ) )\n  })\n  \n  ######\n  # Reset autogrades\n  observeEvent(input$grade_reset,{\n    #shinyjs::reset(\"grading\")\n    hide(\"grade_res\")\n    hide(\"grade_sum\")\n  })\n  \n  \n  ######\n  # Grading show output\n  \n  # Detailed table\n  output$grade_res <- renderTable({\n    tab <- as.matrix( grading()$grade_res )\n    n_task = ncol( tab )\n    scale_points <- tab[1,]/n_task\n    tab <- matrix( scale_points, nrow = 1, ncol = n_task )\n    rownames(tab) <- c('Points:')\n    colnames(tab) <- c(paste( rep('Q',n_task), 1:n_task, sep = '-' ) )\n    return(tab)\n  }, rownames = T)\n  \n  # Final point\n  output$grade_sum <- renderText({\n    if ( is.null(values$upload_state) ){\n      txt = 'No file uploaded!'\n    } else {\n      withProgress(\n        message='Grading in progress',\n        detail='Grading in progress',\n        value = 10,\n        {\n          gr <- grading()\n          #for ( i in seq(0,mints,by=100)){\n          incProgress(1/mints, detail = paste(\"Grading in progress!\"))  \n          #}\n          \n        }\n      )\n      if ( !gr$overflow ){\n        n_task = ncol( gr$grade_res )\n        txt = paste0( 'Overall points: ', round( sum( gr$grade_res[1,] )/n_task, 4 ) , '/', 1 )    \n      } else{\n        txt = paste(\"Grading takes more than \", mints,\n                    \" minutes! Revise your code!\")\n        hide(\"grade_res\")\n      }\n      \n    }\n    return(txt)\n  })\n  \n  hide(\"grade_res\")\n  hide(\"grade_sum\")\n  observeEvent(input$grade,{\n    show(\"grade_res\")\n    show(\"grade_sum\")\n    \n  })\n  \n  \n} # close server\n\nshinyApp(ui, server)\n","type":"text"},{"name":"R/grade.r","content":"#' This function finds unreadable files.\n#'\n#'  A function that finds student submissions with poorly encoded characters\n#' @param submission_dir where the assignments are located\n#' @keywords calcGrades findBadEncodingFiles\n#' @export\n#' @examples\n#' \\donttest{\n#' # change paths to *your* paths\n#' submissions <- \"extdata/assignment1_submissions/\"\n#' findBadEncodingFiles(submissions) # perhaps ask these students to resubmit\n#' }\nfindBadEncodingFiles <- function(submission_dir){\n  scripts_to_grade <- list.files(path = submission_dir, \n                                 recursive = T, \n                                 pattern = \"\\\\.r$\", \n                                 ignore.case = T)  \n  atLeastOneBadFile <- FALSE\n  for(script in scripts_to_grade) {\n    globalPath <- paste(submission_dir, script, sep = \"\")   \n    lines <- readLines(globalPath, warn = F)\n    badLines <- lines[!validUTF8(readLines(globalPath, warn = F))]\n    \n    if(length(badLines) > 0) {\n      atLeastOneBadFile <- TRUE\n      cat(\"======================================================================\\n\")\n      cat(\"In \", script, \"\\n\")\n      for(elem in badLines) cat(elem, \"\\n\")\n    }\n  }\n  if(atLeastOneBadFile) \n    cat(\"======================================================================\\n\")\n}\n\n\n#' This function finds files with global file paths.\n#'\n#'  A function that finds student submissions that refer to machine-specific file paths\n#' @param submission_dir where the assignments are located\n#' @keywords calcGrades findGlobalPaths\n#' @export\n#' @examples\n#' \\donttest{\n#' # change paths to *your* paths\n#' submissions <- \"extdata/assignment1_submissions/\"\n#' findGlobalPaths(submissions) # perhaps ask these students to resubmit\n#' }\nfindGlobalPaths <- function(submission_dir) {\n  scripts_to_grade <- list.files(path = submission_dir, \n                                 recursive = T, \n                                 pattern = \"\\\\.r$\", \n                                 ignore.case = T)\n  \n  atLeastOneBadFile <- FALSE\n  for(script in scripts_to_grade) {\n    globalPath <- paste(submission_dir, script, sep = \"\")\n    lines <- readLines(globalPath, warn = F)  \n    badLines <- suppressWarnings(lines[grep(\"^[^#].+[\\\\\\\\/]+\", lines)])\n    \n    if(length(badLines) > 0) {\n      atLeastOneBadFile <- TRUE\n      cat(\"======================================================================\\n\")\n      cat(\"In \", script, \"\\n\")\n      for(elem in badLines) cat(elem, \"\\n\")\n    }\n  }\n  if(atLeastOneBadFile) \n    cat(\"======================================================================\\n\")\n}\n\n\n#' The grading function.\n#'\n#' This function grades a bunch of R script assignments \n#' @param submission_dir where the assignments are located\n#' @param your_test_file the path to your testthat test file (e.g. grade_hw1.R)\n#' @param suppress_warnings warning handlers prevent code from being run after they catch something. Suppress this behavior by setting this argument to TRUE.\n#' @param verbose set to true if you want to print the name of the file as it's being ran\n#' @keywords calcGrades\n#' @export\n#' @examples\n#' \\donttest{\n#' # change paths to *your* paths\n#' submissions <- \"extdata/example/assignment1_submissions/\"\n#' my_test_file <- system.file(\"extdata/example\", \"grade_hw1.R\", package = \"gradeR\")\n#' results <- calcGrades(submissions, my_test_file)\n#' }\ncalcGrades <- function(submission_dir, your_test_file, suppress_warnings = TRUE, verbose = FALSE){\n\n  if(missing(submission_dir) | missing(your_test_file)) \n    stop(\"the first two arguments are required\")\n  \n  paths <- list.files(path = submission_dir, \n                      recursive = T, \n                      pattern = \"\\\\.r$\", \n                      ignore.case = T)\n  \n  trial_test <- testthat::test_file(your_test_file, reporter = \"minimal\")\n  number_questions <- length(trial_test)\n\n  if(number_questions == 0)\n    stop(\"You need at least one graded question\")\n  \n  number_students <- length(paths)\n  score_data <- data.frame(\"id\" = vector(mode = \"character\", length = number_students), \n                           matrix(data = 0, nrow = number_students, \n                                  ncol = number_questions),\n                           stringsAsFactors = F)\n  \n  student_num <- 1\n  for(path in paths ){\n    \n    # run student's submission in a separate process \n    # https://stackoverflow.com/questions/63744905/attaching-packages-to-a-temporary-search-path-in-r/63746414#63746414\n    tmp_full_path <- paste(submission_dir, path, sep = \"\")\n    if(verbose) cat(\"grading: \", path, \"\\n\")\n    # run student's submission in a separate process\n    # https://stackoverflow.com/a/63746414/1267833\n    rogueScript <- function(source_file_path){\n      rogueEnv <- new.env()  \n      source(source_file_path, rogueEnv)\n      rogueEnv\n    }\n    # remove previous scriptResults in case an error is triggered and it's never re-created\n    if( exists(\"scriptResults\") ) rm(scriptResults)\n    \n    if( suppress_warnings ){\n      tryCatch(\n        suppressWarnings(scriptResults <- callr::r(rogueScript, \n                                                   args = list(tmp_full_path), \n                                                   show = TRUE, package = TRUE)),\n        error = function(e){\n          print(paste0(\"error: \", e$parent$call))\n          print(e$parent$trace)\n        },\n        message = function(m){\n          print(paste0(\"message: \", m))\n        })\n    }else{ # not suppressing warnings\n      tryCatch(\n        scriptResults <- callr::r(rogueScript, \n                                  args = list(tmp_full_path), \n                                  show = TRUE, package = TRUE),\n        error = function(e){\n          print(paste0(\"error: \", e$parent$call))\n          print(e$parent$trace)\n        },\n        message = function(m){\n          print(paste0(\"message: \", m))\n        },\n        warning = function(w){\n          print(paste0(\"warning: \", w))\n        })\n    }\n    \n    # test the student's submissions\n    # note that scriptResults might not exist if there was an error in the tryCatch block\n    if( exists(\"scriptResults\") ){\n      lr <- testthat::ListReporter$new()\n      out <- testthat::test_file(your_test_file, \n                                 reporter = lr,\n                                 env = scriptResults)\n      \n      # parse the output\n      score_data[student_num,1] <- tmp_full_path\n      for(q in (1:number_questions)){\n        \n        # true or false if question was correct\n        assertionResults <- lr$results$as_list()[[q]]$results\n        success <- all(sapply(assertionResults, \n                              methods::is, \n                              \"expectation_success\")) \n        \n        # TODO incorporate point values\n        if(success){\n          score_data[student_num, q+1] <- 1\n        }else{\n          score_data[student_num, q+1] <- 0\n        }\n      }\n      \n    }else{\n      print(\"assigning all zeros for this student due to bug in submissions\")\n      score_data[student_num,1] <- tmp_full_path\n    }\n    \n    # increment \n    student_num <- student_num + 1\n  }\n  \n  # make the column names prettier before returning everything\n  colnames(score_data)[-1] <- sapply(trial_test, `[[`, \"test\")\n  return(score_data)\n}\n\n\n\n#' The grading function for Gradescope.\n#'\n#' This function grades one R script assignment submission and writes results out to a properly-formatted json file for Gradescope. \n#' @param submission_file the name of the assignment submission file (e.g. \"hw1.r\")\n#' @param test_file the name of the .r file with test_that tests (e.g. \"hw1_tests.R\")\n#' @param which_results Choose either \"testing\" or \"gradescope\" If equal to \"gradescope\" then the json file is written out to the directory that Gradescope expects. Otherwise, results.json is written to your current working directory.\n#' @param suppress_warnings If FALSE, warnings are fatal; if set to TRUE, then warnings will not prematurely terminate running of student submission scripts. \n#' @keywords calcGradesForGradescope Gradescope \n#' @export\ncalcGradesForGradescope <- function(submission_file, \n                                    test_file, \n                                    which_results = \"gradescope\",\n                                    suppress_warnings = TRUE){\n  \n  if(!(which_results %in% c(\"gradescope\", \"testing\")))\n    stop(\"argument which_filename incorrectly specified\")\n  json_filename <- ifelse(which_results == \"gradescope\", \"/autograder/results/results.json\", \"results.json\")\n  \n  if(missing(test_file)) \n    stop(\"must have a test file\")\n  \n  number_tests <- length(testthat::test_file(test_file, \n                                             reporter = \"minimal\"))\n  if(number_tests == 0)\n    stop(\"you need at least one graded question\")\n  \n  # run student's submission in a separate process\n  # https://stackoverflow.com/a/63746414/1267833\n  rogueScript <- function(source_file_path){\n    rogueEnv <- new.env()  \n    source(source_file_path, rogueEnv)\n    rogueEnv\n  }\n  if( suppress_warnings ){\n    tryCatch(\n      suppressWarnings(scriptResults <- callr::r(rogueScript, \n                                                 args = list(submission_file), \n                                                 show = TRUE, package = TRUE)),\n      error = function(e){\n        print(paste0(\"error: \", e$parent$call))\n        print(e$parent$trace)\n      },\n      message = function(m){\n        print(paste0(\"message: \", m))\n      })\n  }else{ # not suppressing warnings\n    tryCatch(\n      scriptResults <- callr::r(rogueScript, args = list(submission_file), show = TRUE, package = TRUE),\n      error = function(e){\n        print(paste0(\"error: \", e$parent$call))\n        print(e$parent$trace)\n      },\n      message = function(m){\n        print(paste0(\"message: \", m))\n      },\n      warning = function(w){\n        print(paste0(\"warning: \", w))\n      })\n  }\n\n  \n\n  # test the student's submissions\n  # for the time being, each test is worth one point\n  lr <- testthat::ListReporter$new()\n  out <- testthat::test_file(test_file, \n                             reporter = lr, \n                             env = scriptResults)\n  tests <- list()\n  tests[[\"tests\"]] <- list()\n  raw_results <- lr$results$as_list()\n  for(i in 1:number_tests){\n    test_name <- raw_results[[i]]$test\n    if(  grepl(\"\\\\(visible\\\\)\", test_name) ){\n        test_visibility <- \"visible\"\n    }else if( grepl(\"\\\\(hidden\\\\)\", test_name) ){\n        test_visibility <- \"hidden\"\n    }else if(  grepl(\"\\\\(after_due_date\\\\)\", test_name) ){\n        test_visibility <- \"after_due_date\"\n    }else if( grepl(\"\\\\(after_published\\\\)\", test_name) ){\n        test_visibility <- \"after_published\"\n    }else{\n        test_visibility <- \"after_due_date\"\n    }\n    test_max_score <- 1 # TODO generalize\n    assertionResults <- raw_results[[i]]$results\n    success <- all(sapply(assertionResults, methods::is, \"expectation_success\"))\n    test_score <- ifelse(success, 1, 0)\n    tests[[\"tests\"]][[i]] <- list(name = test_name,\n                                  score = test_score,\n                                  max_score = test_max_score,\n                                  visibility = test_visibility)\n  }\n  \n  # now write out all the stuff to a json file\n  write(jsonlite::toJSON(tests, auto_unbox = T), file = json_filename)\n}\n\n\n","type":"text"},{"name":"R/uni_grader.R","content":"#' The grading function.\n#'\n#' This function grades a bunch of R script assignments \n#' @param submission_dir where the assignments are located\n#' @param your_test_file the path to your testthat test file (e.g. grade_hw1.R)\n#' @param suppress_warnings warning handlers prevent code from being run after they catch something. Suppress this behavior by setting this argument to TRUE.\n#' @param verbose set to true if you want to print the name of the file as it's being ran\n#' @keywords calcGrades\n#' @export\n#' @examples\n#' \\donttest{\n#' # change paths to *your* paths\n#' submissions <- \"extdata/example/assignment1_submissions/\"\n#' my_test_file <- system.file(\"extdata/example\", \"grade_hw1.R\", package = \"gradeR\")\n#' results <- calcGrades(submissions, my_test_file)\n#' }\ncalc_one_Grade <- function(submission_file, your_test_file, suppress_warnings = TRUE, verbose = FALSE){\n  \n  if(missing(submission_file) | missing(your_test_file)) \n    stop(\"the first two arguments are required\")\n  \n  path <- submission_file\n  \n  trial_test <- testthat::test_file(your_test_file, reporter = \"minimal\")\n  number_questions <- length(trial_test)\n  \n  if(number_questions == 0)\n    stop(\"You need at least one graded question\")\n  \n  number_students <- length(path)\n  score_data <- data.frame(\"id\" = vector(mode = \"character\", length = number_students), \n                           matrix(data = 0, nrow = number_students, \n                                  ncol = number_questions),\n                           stringsAsFactors = F)\n  \n  student_num <- 1\n  #for(path in paths ){\n    \n    # run student's submission in a separate process \n    # https://stackoverflow.com/questions/63744905/attaching-packages-to-a-temporary-search-path-in-r/63746414#63746414\n    tmp_full_path <- path #paste(submission_dir, path, sep = \"\")\n    if(verbose) cat(\"grading: \", path, \"\\n\")\n    # run student's submission in a separate process\n    # https://stackoverflow.com/a/63746414/1267833\n    rogueScript <- function(source_file_path){\n      rogueEnv <- new.env()  \n      source(source_file_path, rogueEnv)\n      rogueEnv\n    }\n    # remove previous scriptResults in case an error is triggered and it's never re-created\n    if( exists(\"scriptResults\") ) rm(scriptResults)\n    \n    if( suppress_warnings ){\n      tryCatch(\n        suppressWarnings(scriptResults <- callr::r(rogueScript, \n                                                   args = list(tmp_full_path), \n                                                   show = TRUE, package = TRUE)),\n        error = function(e){\n          print(paste0(\"error: \", e$parent$call))\n          print(e$parent$trace)\n        },\n        message = function(m){\n          print(paste0(\"message: \", m))\n        })\n    }else{ # not suppressing warnings\n      tryCatch(\n        scriptResults <- callr::r(rogueScript, \n                                  args = list(tmp_full_path), \n                                  show = TRUE, package = TRUE),\n        error = function(e){\n          print(paste0(\"error: \", e$parent$call))\n          print(e$parent$trace)\n        },\n        message = function(m){\n          print(paste0(\"message: \", m))\n        },\n        warning = function(w){\n          print(paste0(\"warning: \", w))\n        })\n    }\n    \n    # test the student's submissions\n    # note that scriptResults might not exist if there was an error in the tryCatch block\n    if( exists(\"scriptResults\") ){\n      lr <- testthat::ListReporter$new()\n      out <- testthat::test_file(your_test_file, \n                                 reporter = lr,\n                                 env = scriptResults)\n      \n      # parse the output\n      score_data[student_num,1] <- tmp_full_path\n      for(q in (1:number_questions)){\n        \n        # true or false if question was correct\n        assertionResults <- lr$results$as_list()[[q]]$results\n        success <- all(sapply(assertionResults, \n                              methods::is, \n                              \"expectation_success\")) \n        \n        # TODO incorporate point values\n        if(success){\n          score_data[student_num, q+1] <- 1\n        }else{\n          score_data[student_num, q+1] <- 0\n        }\n      }\n      \n    }else{\n      print(\"assigning all zeros for this student due to bug in submissions\")\n      score_data[student_num,1] <- tmp_full_path\n    }\n    \n    # increment \n    student_num <- student_num + 1\n  #}\n  \n  # make the column names prettier before returning everything\n  colnames(score_data)[-1] <- sapply(trial_test, `[[`, \"test\")\n  return(score_data)\n}","type":"text"},{"name":"autograder_shiny.Rproj","content":"Version: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: pdfLaTeX\n","type":"text"},{"name":"deploy/github_deploy.R","content":"# Deploy in GitHub\n\nlibrary(shinylive)\nlibrary(httpuv)\n\nshinylive::export(appdir = \"~/Library/CloudStorage/OneDrive-CorvinusUniversityofBudapest/Teaching/Okonometria_I/autograder_shiny/\", \n                  destdir = \"~/Library/CloudStorage/OneDrive-CorvinusUniversityofBudapest/Teaching/Okonometria_I/autograder_shiny_deploy/docs\")\n\nhttpuv::runStaticServer(\"/Users/areguly6/Documents/Personal/Webpage/regulyagoston.github.io/teaching/autograde/docs\", port=8008)\n","type":"text"},{"name":"rm/server.R","content":"#####\n# Server\nserver <- function(input, output, session) {\n  \n  \n  ########################\n  # Handle uploaded file\n  # Reset submitted script\n  values <- reactiveValues(\n    upload_state = NULL\n  )\n  \n  # New upload\n  observeEvent(input$inFile, {\n    values$upload_state <- 'Uploaded'\n  })\n  \n  observeEvent(input$reset, {\n    shinyjs::reset()\n    values$upload_state <- NULL\n    hide(\"grade_res\")\n    hide(\"grade_sum\")\n  })\n  \n  \n  file_input <- reactive({\n    if (is.null(values$upload_state)) {\n      return(\"No file uploaded.\")\n    } else if (values$upload_state == 'Uploaded') {\n      return(input$inFile)\n    }\n  })\n  \n  ##\n  # Output for file upload\n  output$summary <- renderText({\n    txt = ifelse( values$upload_state == 'Uploaded' , \n                  paste(\"Uploaded file:\", file_input()$name ),\n                  file_input() )\n    return(txt)\n  })\n  \n  ##\n  # Check validity of uploaded name\n  output$chck_name <- renderText({\n    \n    # chck function\n    chck_name <- function( inputfile ){\n      tryCatch({\n        any( substr( file_input()$name, 0, 6 ) == neptun_codes )\n      }, \n      error = function( e )\n        NULL\n      )\n    }\n    \n    txt = ifelse( !is.null( chck_name ),\n                  ifelse( chck_name(),\n                          'Valid script name!',\n                          'Invalid script name! Use your neptun code as the first 6 character of your submission file!' ),\n                  'No file uploaded!')\n    \n    return(txt)\n    \n    #if ( values$upload_state == 'Uploaded' ){\n    #  chck = any( substr( file_input()$name, 0, 6 ) == neptun_codes )\n    #  if ( chck ){\n    #    txt = 'Valid script name!'\n    #  } else{\n    #    txt = 'Invalid script name! Use your neptun code as the first 6 character of your submission file!'\n    #  }\n    #} else{\n    #  txt = ''\n    #}\n    \n  })\n  \n  ########################\n  # Process uploaded file\n  \n  grading <- eventReactive( input$grade, {\n    if ( is.character( file_input ) ){\n      \n      showNotification(\"No script file uploaded!\")\n      overflow = F\n      grade_res = NULL\n      \n    } else{\n      \n      showNotification(\"Grading in progress!\")\n      \n      # Process input\n      #script = readLines( input$inFile$datapath )\n      path_file = file_input()$datapath\n      \n      # Start grading\n      if ( input$assign == 'as1' ){\n        Mytestfile <- './solutions/solution_week01.R'\n      } else if ( input$assign == 'as2' ){\n        Mytestfile <- './solutions/solution_week02.R'\n      }\n      \n      # Eval function\n      grade <- function( path_file, Mytestfile ){\n        tryCatch({\n          calc_one_Grade( path_file, Mytestfile,\n                          suppress_warnings = F,\n                          verbose = TRUE )\n        }, \n        error = function( e )\n          NULL\n        )\n      }\n      \n      setTimeLimit( elapsed = mints*60 ) # After x minutes it will shut downe\n      st=Sys.time()\n      grade_res <- grade( path_file, Mytestfile )\n      et = Sys.time() - st\n      setTimeLimit( elapsed = Inf )\n      \n      overflow = F\n      if ( et >= mints ){\n        grade_res = NULL\n        overflow =T \n      }\n      \n      if ( !is.null( grade_res ) ){\n        # Remove ID\n        grade_res[,1] = NULL\n        \n        # Inform\n        showNotification(\"Grading is done!\")\n      } else{\n        \n        # Inform\n        showNotification(paste(\"Grading takes more than \", mints,\n                               \" minutes! Revise your code!\") )\n      }\n    }\n    return( list( grade_res = grade_res, overflow = overflow ) )\n  })\n  \n  ######\n  # Reset autogrades\n  observeEvent(input$grade_reset,{\n    #shinyjs::reset(\"grading\")\n    hide(\"grade_res\")\n    hide(\"grade_sum\")\n  })\n  \n  \n  ######\n  # Grading show output\n  \n  # Detailed table\n  output$grade_res <- renderTable({\n    tab <- as.matrix( grading()$grade_res )\n    n_task = ncol( tab )\n    scale_points <- tab[1,]/n_task\n    tab <- matrix( scale_points, nrow = 1, ncol = n_task )\n    rownames(tab) <- c('Points:')\n    colnames(tab) <- c(paste( rep('Q',n_task), 1:n_task, sep = '-' ) )\n    return(tab)\n  }, rownames = T)\n  \n  # Final point\n  output$grade_sum <- renderText({\n    if ( is.null(values$upload_state) ){\n      txt = 'No file uploaded!'\n    } else {\n      withProgress(\n        message='Grading in progress',\n        detail='Grading in progress',\n        value = 10,\n        {\n          gr <- grading()\n          #for ( i in seq(0,mints,by=100)){\n          incProgress(1/mints, detail = paste(\"Grading in progress!\"))  \n          #}\n          \n        }\n      )\n      if ( !gr$overflow ){\n        n_task = ncol( gr$grade_res )\n        txt = paste0( 'Overall points: ', round( sum( gr$grade_res[1,] )/n_task, 4 ) , '/', 1 )    \n      } else{\n        txt = paste(\"Grading takes more than \", mints,\n                    \" minutes! Revise your code!\")\n        hide(\"grade_res\")\n      }\n      \n    }\n    return(txt)\n  })\n  \n  hide(\"grade_res\")\n  hide(\"grade_sum\")\n  observeEvent(input$grade,{\n    show(\"grade_res\")\n    show(\"grade_sum\")\n    \n  })\n  \n  \n} # close server","type":"text"},{"name":"rm/ui.R","content":"library(shiny)\nlibrary(shinyjs)\nlibrary(stringr)\n\n\n\n# Set the MAX minutes to process\nmints = 1\nneptun_codes = c('asd123','gvk123')\n\n##\n# Slide bars\nui <- fluidPage(\n  useShinyjs(),\n  \n  tags$br(), \n  tags$br(),\n  \n  fluidPage(\n    h3(\"Upload R-script\"),\n    fileInput('inFile', 'Choose file'),\n    actionButton('reset', 'Reset'),\n    h3(\"Script status:\"),\n    verbatimTextOutput(\"summary\"),\n    verbatimTextOutput(\"chck_name\")\n  ),\n  \n  tags$br(), \n  tags$br(),\n  \n  fluidPage(\n    h3(\"Select Assignment\"),\n    selectInput(\"assign\", \"Assignment:\",\n                c(\"Assignment 1\" = \"as1\",\n                  \"Assignment 2\" = \"as2\",\n                  \"Assignment 3\" = \"as3\")),\n    tags$br(),\n    fluidRow(\n      actionButton('grade', 'Autograde', class = \"btn-primary\"),\n      #actionButton(\"stop\", \"Stop\", class = \"btn-danger\"),\n      actionButton('grade_reset', 'Reset')\n    ),\n    h6(paste('Autograding can take up to ', mints, ' minutes maximum.')),\n    h6('After that it will exit and not evaluate your code.'),\n    tags$br(),\n    h3(\"Grade status:\"),\n    tableOutput(\"grade_res\"),\n    verbatimTextOutput(\"grade_sum\")\n  )\n  \n) # close fluid page\n","type":"text"},{"name":"solutions/solution_week01.R","content":"###########################################\r\n### THIS FILE GRADES THE HOMEWORK of WEEK 1\r\n### Bence Szabó\r\n### 2023.09.09.\r\n###########################################\r\n\r\nlibrary(testthat)\r\n\r\n### function to clear strings\r\nclear_commands = function(s){\r\n  if(is.character(s)){\r\n    s_clear = stringr::str_remove_all(s, \" \")\r\n    s_clear = stringr::str_replace_all(s_clear, \"<-\", \"=\")\r\n  }\r\n  else{}\r\n  return(s_clear)\r\n}\r\n\r\n#######################\r\n## SOLUTIONS\r\n#######################\r\n\r\n# first test\r\ntest_that(\"Q01\", {\r\n  \r\n  expect_true(length(ls()) == 0) \r\n  \r\n})\r\n\r\n# second test\r\ntest_that(\"Q02\", {\r\n\r\n  expect_true(str_var == 'This is my first assignment in R!')\r\n  \r\n})\r\n\r\n# third test\r\ntest_that(\"Q03\", {\r\n  \r\n  expect_true(clear_commands(check_if_character) == \r\n                clear_commands(\"typeof(str_var) == 'character'\")\r\n              )\r\n  \r\n}\r\n)\r\n\r\ntest_that(\"Q04\", {\r\n  expect_equal(v, c(3, 363, 777, 2021, -987, Inf))\r\n})\r\n\r\ntest_that(\"Q05\", {\r\n  expect_equal(v_10, c(3, 363, 777, 2021, -987, Inf) * 10)\r\n})\r\n\r\ntest_that(\"Q06\", {\r\n  expect_equal(mL, list(str_var, c(3, 363, 777, 2021, -987, Inf)))\r\n})\r\n\r\ntest_that(\"Q07\", {\r\n  expect_true(clear_commands(get_inf) == clear_commands(\"x <- mL[[2]][mL[[2]] == Inf]\")\r\n              )\r\n})\r\n\r\ntest_that(\"Q08\", {\r\n  expect_true(clear_commands(check_if_inf) == clear_commands(\"is_inf <- (x == Inf)\")\r\n              )\r\n})\r\n\r\n\r\n\r\n\r\n","type":"text"},{"name":"solutions/solution_week02.R","content":"###########################################\r\n### THIS FILE GRADES THE HOMEWORK of WEEK 1\r\n### Bence Szabó\r\n### 2023.09.09.\r\n###########################################\r\n\r\nlibrary(testthat)\r\n\r\n### function to clear strings\r\nclear_commands = function(s){\r\n  if(is.character(s)){\r\n    s_clear = stringr::str_remove_all(s, \" \")\r\n    s_clear = stringr::str_replace_all(s_clear, \"<-\", \"=\")\r\n  }\r\n  else{}\r\n  return(s_clear)\r\n}\r\n\r\n#######################\r\n## SOLUTIONS\r\n#######################\r\n\r\n# first test\r\ntest_that(\"Q01\", {\r\n  \r\n  expect_true(length(ls()) == 0) \r\n  \r\n})\r\n\r\n# second test\r\ntest_that(\"Q02\", {\r\n\r\n  expect_true(str_var == 'This is my first assignment in R!')\r\n  \r\n})\r\n\r\n# third test\r\ntest_that(\"Q03\", {\r\n  \r\n  expect_true(clear_commands(check_if_character) == \r\n                clear_commands(\"typeof(str_var) == 'character'\")\r\n              )\r\n  \r\n}\r\n)\r\n\r\ntest_that(\"Q04\", {\r\n  expect_equal(v, c(3, 363, 777, 2021, -987, Inf))\r\n})\r\n\r\ntest_that(\"Q05\", {\r\n  expect_equal(v_10, c(3, 363, 777, 2021, -987, Inf) * 10)\r\n})\r\n\r\ntest_that(\"Q06\", {\r\n  expect_equal(mL, list(str_var, c(3, 363, 777, 2021, -987, Inf)))\r\n})\r\n\r\ntest_that(\"Q07\", {\r\n  expect_true(clear_commands(get_inf) == clear_commands(\"x <- mL[[2]][mL[[2]] == Inf]\")\r\n              )\r\n})\r\n\r\ntest_that(\"Q08\", {\r\n  expect_true(clear_commands(check_if_inf) == clear_commands(\"is_inf <- (x == Inf)\")\r\n              )\r\n})\r\n\r\n\r\n\r\n\r\n","type":"text"}]
